CCS PCM C Compiler, Version 4.130, 5967               30-mar-16 10:44

               Filename: C:\Users\Administrador.JPAD227381\Downloads\Passo\Motor de passo\Passo.lst

               ROM used: 1447 words (18%)
                         Largest free fragment is 2048
               RAM used: 40 (11%) at main() level
                         58 (16%) worst case
               Stack:    5 locations

*
0000:  MOVLW  04
0001:  MOVWF  0A
0002:  GOTO   4DF
0003:  NOP
.................... #include <16F877A.h> 
.................... //////// Standard Header file for the PIC16F877A device //////////////// 
.................... #device PIC16F877A 
.................... #list 
....................  
.................... #device adc=10 
.................... #FUSES NOWDT,XT,PUT,NOPROTECT,NODEBUG,BROWNOUT,NOLVP,NOCPD  
.................... #use delay(clock=4000000) 
*
0110:  MOVLW  4D
0111:  MOVWF  04
0112:  BCF    03.7
0113:  MOVF   00,W
0114:  BTFSC  03.2
0115:  GOTO   124
0116:  MOVLW  01
0117:  MOVWF  78
0118:  CLRF   77
0119:  DECFSZ 77,F
011A:  GOTO   119
011B:  DECFSZ 78,F
011C:  GOTO   118
011D:  MOVLW  4A
011E:  MOVWF  77
011F:  DECFSZ 77,F
0120:  GOTO   11F
0121:  GOTO   122
0122:  DECFSZ 00,F
0123:  GOTO   116
0124:  RETURN
.................... #include <flex_lcd.c> 
.................... // flex_lcd.c  
....................  
.................... // Altere aqui os pinos para cada microcontrolador,  
....................   
....................  
.................... #define LCD_DB4   PIN_C4  
.................... #define LCD_DB5   PIN_C5  
.................... #define LCD_DB6   PIN_C6  
.................... #define LCD_DB7   PIN_C7  
....................  
.................... #define LCD_E     PIN_C0 
.................... #define LCD_RS    PIN_C1  
.................... //#define LCD_RW    PIN_C2 //descomentar para usar com 7 pinos  
....................  
.................... // If you only want a 6-pin interface to your LCD, then  
.................... // connect the R/W pin on the LCD to ground, and comment  
.................... // out the following line.  
....................  
.................... //#define USE_LCD_RW   1 //descomentar para usar com 7 pinos      
....................  
.................... //========================================  
....................  
.................... #define lcd_type 2        // 0=5x7, 1=5x10, 2=2 lines  
.................... #define lcd_line_two 0x40 // LCD RAM address for the 2nd line  
....................  
....................  
.................... int8 const LCD_INIT_STRING[4] =  
.................... {  
....................  0x20 | (lcd_type << 2), // Func set: 4-bit, 2 lines, 5x8 dots  
....................  0xc,                    // Display on  
....................  1,                      // Clear display  
....................  6                       // Increment cursor  
....................  };  
....................                                
....................  
.................... //-------------------------------------  
.................... void lcd_send_nibble(int8 nibble)  
.................... {  
.................... // Note:  !! converts an integer expression  
.................... // to a boolean (1 or 0).  
....................  output_bit(LCD_DB4, !!(nibble & 1));  
0125:  BTFSC  54.0
0126:  GOTO   129
0127:  BCF    07.4
0128:  GOTO   12A
0129:  BSF    07.4
012A:  BCF    20.4
012B:  MOVF   20,W
012C:  BSF    03.5
012D:  MOVWF  07
....................  output_bit(LCD_DB5, !!(nibble & 2));   
012E:  BCF    03.5
012F:  BTFSC  54.1
0130:  GOTO   133
0131:  BCF    07.5
0132:  GOTO   134
0133:  BSF    07.5
0134:  BCF    20.5
0135:  MOVF   20,W
0136:  BSF    03.5
0137:  MOVWF  07
....................  output_bit(LCD_DB6, !!(nibble & 4));     
0138:  BCF    03.5
0139:  BTFSC  54.2
013A:  GOTO   13D
013B:  BCF    07.6
013C:  GOTO   13E
013D:  BSF    07.6
013E:  BCF    20.6
013F:  MOVF   20,W
0140:  BSF    03.5
0141:  MOVWF  07
....................  output_bit(LCD_DB7, !!(nibble & 8));     
0142:  BCF    03.5
0143:  BTFSC  54.3
0144:  GOTO   147
0145:  BCF    07.7
0146:  GOTO   148
0147:  BSF    07.7
0148:  BCF    20.7
0149:  MOVF   20,W
014A:  BSF    03.5
014B:  MOVWF  07
....................  
....................  delay_cycles(1);  
014C:  NOP
....................  output_high(LCD_E);  
014D:  BCF    03.5
014E:  BCF    20.0
014F:  MOVF   20,W
0150:  BSF    03.5
0151:  MOVWF  07
0152:  BCF    03.5
0153:  BSF    07.0
....................  delay_us(2);  
0154:  GOTO   155
....................  output_low(LCD_E);  
0155:  BCF    20.0
0156:  MOVF   20,W
0157:  BSF    03.5
0158:  MOVWF  07
0159:  BCF    03.5
015A:  BCF    07.0
.................... }  
015B:  RETURN
....................  
.................... //-----------------------------------  
....................      
....................  
.................... #ifdef USE_LCD_RW  
.................... int8 lcd_read_nibble(void)  
.................... {  
.................... int8 retval;  
.................... #bit retval_0 = retval.0  
.................... #bit retval_1 = retval.1  
.................... #bit retval_2 = retval.2  
.................... #bit retval_3 = retval.3  
....................  
.................... retval = 0;  
....................      
.................... output_high(LCD_E);  
.................... delay_cycles(1);  
....................  
.................... retval_0 = input(LCD_DB4);  
.................... retval_1 = input(LCD_DB5);  
.................... retval_2 = input(LCD_DB6);  
.................... retval_3 = input(LCD_DB7);  
....................    
.................... output_low(LCD_E);  
....................      
.................... return(retval);     
.................... }     
.................... #endif  
....................  
.................... //---------------------------------------  
.................... // Read a byte from the LCD and return it.  
....................  
.................... #ifdef USE_LCD_RW  
.................... int8 lcd_read_byte(void)  
.................... {  
.................... int8 low;  
.................... int8 high;  
....................  
.................... output_high(LCD_RW);  
.................... delay_cycles(1);  
....................  
.................... high = lcd_read_nibble();  
....................  
.................... low = lcd_read_nibble();  
....................  
.................... return( (high<<4) | low);  
.................... }  
.................... #endif  
....................  
.................... //----------------------------------------  
.................... // Send a byte to the LCD.  
.................... void lcd_send_byte(int8 address, int8 n)  
.................... {  
.................... output_low(LCD_RS);  
015C:  BCF    20.1
015D:  MOVF   20,W
015E:  BSF    03.5
015F:  MOVWF  07
0160:  BCF    03.5
0161:  BCF    07.1
....................  
.................... #ifdef USE_LCD_RW  
.................... while(bit_test(lcd_read_byte(),7)) ;  
.................... #else  
.................... delay_us(60);   
0162:  MOVLW  13
0163:  MOVWF  77
0164:  DECFSZ 77,F
0165:  GOTO   164
0166:  GOTO   167
.................... #endif  
....................  
.................... if(address)  
0167:  MOVF   51,F
0168:  BTFSC  03.2
0169:  GOTO   171
....................    output_high(LCD_RS);  
016A:  BCF    20.1
016B:  MOVF   20,W
016C:  BSF    03.5
016D:  MOVWF  07
016E:  BCF    03.5
016F:  BSF    07.1
.................... else  
0170:  GOTO   177
....................    output_low(LCD_RS);  
0171:  BCF    20.1
0172:  MOVF   20,W
0173:  BSF    03.5
0174:  MOVWF  07
0175:  BCF    03.5
0176:  BCF    07.1
....................        
....................  delay_cycles(1);  
0177:  NOP
....................  
.................... #ifdef USE_LCD_RW  
.................... output_low(LCD_RW);  
.................... delay_cycles(1);  
.................... #endif  
....................  
.................... output_low(LCD_E);  
0178:  BCF    20.0
0179:  MOVF   20,W
017A:  BSF    03.5
017B:  MOVWF  07
017C:  BCF    03.5
017D:  BCF    07.0
....................  
.................... lcd_send_nibble(n >> 4);  
017E:  SWAPF  52,W
017F:  MOVWF  53
0180:  MOVLW  0F
0181:  ANDWF  53,F
0182:  MOVF   53,W
0183:  MOVWF  54
0184:  CALL   125
.................... lcd_send_nibble(n & 0xf);  
0185:  MOVF   52,W
0186:  ANDLW  0F
0187:  MOVWF  53
0188:  MOVWF  54
0189:  CALL   125
.................... }  
018A:  RETURN
....................  
.................... //----------------------------  
.................... void lcd_init(void)  
.................... {  
.................... int8 i;  
....................  
.................... output_low(LCD_RS);  
018B:  BCF    20.1
018C:  MOVF   20,W
018D:  BSF    03.5
018E:  MOVWF  07
018F:  BCF    03.5
0190:  BCF    07.1
....................  
.................... #ifdef USE_LCD_RW  
.................... output_low(LCD_RW);  
.................... #endif  
....................  
.................... output_low(LCD_E);  
0191:  BCF    20.0
0192:  MOVF   20,W
0193:  BSF    03.5
0194:  MOVWF  07
0195:  BCF    03.5
0196:  BCF    07.0
....................  
.................... delay_ms(15);  
0197:  MOVLW  0F
0198:  MOVWF  4D
0199:  CALL   110
....................  
.................... for(i=0 ;i < 3; i++)  
019A:  CLRF   3F
019B:  MOVF   3F,W
019C:  SUBLW  02
019D:  BTFSS  03.0
019E:  GOTO   1A7
....................    {  
....................     lcd_send_nibble(0x03);  
019F:  MOVLW  03
01A0:  MOVWF  54
01A1:  CALL   125
....................     delay_ms(5);  
01A2:  MOVLW  05
01A3:  MOVWF  4D
01A4:  CALL   110
....................    }  
01A5:  INCF   3F,F
01A6:  GOTO   19B
....................  
.................... lcd_send_nibble(0x02);  
01A7:  MOVLW  02
01A8:  MOVWF  54
01A9:  CALL   125
....................  
.................... for(i=0; i < sizeof(LCD_INIT_STRING); i++)  
01AA:  CLRF   3F
01AB:  MOVF   3F,W
01AC:  SUBLW  03
01AD:  BTFSS  03.0
01AE:  GOTO   1BB
....................    {  
....................     lcd_send_byte(0, LCD_INIT_STRING[i]);  
01AF:  MOVF   3F,W
01B0:  CALL   004
01B1:  MOVWF  40
01B2:  CLRF   51
01B3:  MOVF   40,W
01B4:  MOVWF  52
01B5:  CALL   15C
....................     #ifndef USE_LCD_RW  
....................     delay_ms(5);  
01B6:  MOVLW  05
01B7:  MOVWF  4D
01B8:  CALL   110
....................     #endif  
....................    }  
01B9:  INCF   3F,F
01BA:  GOTO   1AB
....................  
.................... }  
01BB:  BCF    0A.3
01BC:  BCF    0A.4
01BD:  GOTO   532 (RETURN)
....................  
.................... //----------------------------  
....................  
.................... void lcd_gotoxy(int8 x, int8 y)  
.................... {  
.................... int8 address;  
....................  
.................... if(y != 1)  
*
01D5:  DECFSZ 4E,W
01D6:  GOTO   1D8
01D7:  GOTO   1DB
....................    address = lcd_line_two;  
01D8:  MOVLW  40
01D9:  MOVWF  4F
.................... else  
01DA:  GOTO   1DC
....................    address=0;  
01DB:  CLRF   4F
....................  
.................... address += x-1;  
01DC:  MOVLW  01
01DD:  SUBWF  4D,W
01DE:  ADDWF  4F,F
.................... lcd_send_byte(0, 0x80 | address);  
01DF:  MOVF   4F,W
01E0:  IORLW  80
01E1:  MOVWF  50
01E2:  CLRF   51
01E3:  MOVF   50,W
01E4:  MOVWF  52
01E5:  CALL   15C
.................... }  
....................  
.................... //-----------------------------  
.................... void lcd_putc(char c)  
.................... {  
....................  switch(c)  
....................    {  
*
01BE:  MOVF   4C,W
01BF:  XORLW  0C
01C0:  BTFSC  03.2
01C1:  GOTO   1C9
01C2:  XORLW  06
01C3:  BTFSC  03.2
01C4:  GOTO   1D1
01C5:  XORLW  02
01C6:  BTFSC  03.2
01C7:  GOTO   1E7
01C8:  GOTO   1EC
....................     case '\f':  
....................       lcd_send_byte(0,1);  
01C9:  CLRF   51
01CA:  MOVLW  01
01CB:  MOVWF  52
01CC:  CALL   15C
....................       delay_ms(2);  
01CD:  MOVLW  02
01CE:  MOVWF  4D
01CF:  CALL   110
....................       break;  
01D0:  GOTO   1F2
....................      
....................     case '\n':  
....................        lcd_gotoxy(1,2);  
01D1:  MOVLW  01
01D2:  MOVWF  4D
01D3:  MOVLW  02
01D4:  MOVWF  4E
....................        break;  
*
01E6:  GOTO   1F2
....................      
....................     case '\b':  
....................        lcd_send_byte(0,0x10);  
01E7:  CLRF   51
01E8:  MOVLW  10
01E9:  MOVWF  52
01EA:  CALL   15C
....................        break;  
01EB:  GOTO   1F2
....................      
....................     default:  
....................        lcd_send_byte(1,c);  
01EC:  MOVLW  01
01ED:  MOVWF  51
01EE:  MOVF   4C,W
01EF:  MOVWF  52
01F0:  CALL   15C
....................        break;  
01F1:  GOTO   1F2
....................    }  
.................... }  
01F2:  RETURN
....................  
.................... //------------------------------  
.................... #ifdef USE_LCD_RW  
.................... char lcd_getc(int8 x, int8 y)  
.................... {  
.................... char value;  
....................  
.................... lcd_gotoxy(x,y);  
....................  
.................... while(bit_test(lcd_read_byte(),7));   
....................    output_high(LCD_RS);  
....................    value = lcd_read_byte();  
....................    output_low(lcd_RS);  
....................    return(value);  
....................    }  
.................... #endif 
....................  
.................... #define frame_time      0                  //Velocidade do motor 
....................  
.................... int8 i = 3, i_1 = 0,j; 
.................... int16 ad_antigo, ad_atual, total_passos, posicoes_na_escala; 
.................... signed int16 pos_atual =0; 
.................... int16 passos_dados =0; 
.................... int16 ultimaRPM = 0; 
.................... int16 rpm=0; 
.................... float passos_por_posicao; 
.................... int8 y; 
.................... signed int16 distancia; 
....................  
.................... char motor[4]= 
....................   { 
....................      0b1100, //PASSO1 
....................      0b0110, //PASSO2 
....................      0b0011, //PASSO3 
....................      0b1001, //PASSO4       
....................   };   
*
04F7:  MOVLW  0C
04F8:  BCF    03.5
04F9:  MOVWF  3B
04FA:  MOVLW  06
04FB:  MOVWF  3C
04FC:  MOVLW  03
04FD:  MOVWF  3D
04FE:  MOVLW  09
04FF:  MOVWF  3E
....................   
.................... //int16 rpms[5]={9,35,9,20,65}; 
....................     
....................    
....................    
.................... void avanca(int16 qtdPassos){ 
....................    if(qtdPassos>total_passos){ 
*
023E:  MOVF   29,W
023F:  SUBWF  44,W
0240:  BTFSS  03.0
0241:  GOTO   24F
0242:  BTFSS  03.2
0243:  GOTO   248
0244:  MOVF   43,W
0245:  SUBWF  28,W
0246:  BTFSC  03.0
0247:  GOTO   24F
....................       qtdPassos=total_passos+1; //Estabelecendo o limite máximo 
0248:  MOVLW  01
0249:  ADDWF  28,W
024A:  MOVWF  43
024B:  MOVF   29,W
024C:  MOVWF  44
024D:  BTFSC  03.0
024E:  INCF   44,F
....................    } 
....................    int16 passos=qtdPassos-passos_dados; 
024F:  MOVF   2E,W
0250:  SUBWF  43,W
0251:  MOVWF  45
0252:  MOVF   44,W
0253:  MOVWF  46
0254:  MOVF   2F,W
0255:  BTFSS  03.0
0256:  INCFSZ 2F,W
0257:  SUBWF  46,F
....................    passos_dados=qtdPassos; 
0258:  MOVF   44,W
0259:  MOVWF  2F
025A:  MOVF   43,W
025B:  MOVWF  2E
....................    for (i=0;i<passos;i++){ 
025C:  CLRF   21
025D:  MOVF   46,F
025E:  BTFSS  03.2
025F:  GOTO   264
0260:  MOVF   45,W
0261:  SUBWF  21,W
0262:  BTFSC  03.0
0263:  GOTO   284
....................       pos_atual++;       
0264:  INCF   2C,F
0265:  BTFSC  03.2
0266:  INCF   2D,F
....................       if(pos_atual>3){ 
0267:  BTFSC  2D.7
0268:  GOTO   272
0269:  MOVF   2D,F
026A:  BTFSS  03.2
026B:  GOTO   270
026C:  MOVF   2C,W
026D:  SUBLW  03
026E:  BTFSC  03.0
026F:  GOTO   272
....................          pos_atual = 0; 
0270:  CLRF   2D
0271:  CLRF   2C
....................       }  
....................       output_b(motor[pos_atual]);             
0272:  MOVLW  3B
0273:  ADDWF  2C,W
0274:  MOVWF  04
0275:  BCF    03.7
0276:  BTFSC  2D.0
0277:  BSF    03.7
0278:  MOVF   00,W
0279:  MOVWF  47
027A:  BSF    03.5
027B:  CLRF   06
027C:  BCF    03.5
027D:  MOVF   47,W
027E:  MOVWF  06
....................       delay_ms (3); 
027F:  MOVLW  03
0280:  MOVWF  4D
0281:  CALL   110
....................    }    
0282:  INCF   21,F
0283:  GOTO   25D
.................... } 
0284:  RETURN
....................  
.................... void retrocede(int16 qtdPassos){ 
*
0474:  MOVF   43,W
0475:  SUBWF  2E,W
0476:  MOVWF  45
0477:  MOVF   2F,W
0478:  MOVWF  46
0479:  MOVF   44,W
047A:  BTFSS  03.0
047B:  INCFSZ 44,W
047C:  SUBWF  46,F
....................    int16 passos=passos_dados-qtdPassos; 
....................    passos_dados=qtdPassos;    
047D:  MOVF   44,W
047E:  MOVWF  2F
047F:  MOVF   43,W
0480:  MOVWF  2E
....................     
....................    if(qtdPassos>passos_dados){ 
0481:  MOVF   2F,W
0482:  SUBWF  44,W
0483:  BTFSS  03.0
0484:  GOTO   491
0485:  BTFSS  03.2
0486:  GOTO   48B
0487:  MOVF   43,W
0488:  SUBWF  2E,W
0489:  BTFSC  03.0
048A:  GOTO   491
....................       passos= passos_dados; 
048B:  MOVF   2F,W
048C:  MOVWF  46
048D:  MOVF   2E,W
048E:  MOVWF  45
....................       passos_dados = 0; 
048F:  CLRF   2F
0490:  CLRF   2E
....................    } 
....................     
....................    passos_dados=qtdPassos;    
0491:  MOVF   44,W
0492:  MOVWF  2F
0493:  MOVF   43,W
0494:  MOVWF  2E
....................    for (i=0;i<passos;i++){       
0495:  CLRF   21
0496:  MOVF   46,F
0497:  BTFSS  03.2
0498:  GOTO   49D
0499:  MOVF   45,W
049A:  SUBWF  21,W
049B:  BTFSC  03.0
049C:  GOTO   4B8
....................       pos_atual--;   
049D:  MOVF   2C,W
049E:  BTFSC  03.2
049F:  DECF   2D,F
04A0:  DECF   2C,F
....................       if(pos_atual<0){ 
04A1:  BTFSS  2D.7
04A2:  GOTO   4A6
....................          pos_atual = 3; 
04A3:  CLRF   2D
04A4:  MOVLW  03
04A5:  MOVWF  2C
....................       }  
....................       output_b(motor[pos_atual]);               
04A6:  MOVLW  3B
04A7:  ADDWF  2C,W
04A8:  MOVWF  04
04A9:  BCF    03.7
04AA:  BTFSC  2D.0
04AB:  BSF    03.7
04AC:  MOVF   00,W
04AD:  MOVWF  47
04AE:  BSF    03.5
04AF:  CLRF   06
04B0:  BCF    03.5
04B1:  MOVF   47,W
04B2:  MOVWF  06
....................       delay_ms (3); 
04B3:  MOVLW  03
04B4:  MOVWF  4D
04B5:  CALL   110
....................    }         
04B6:  INCF   21,F
04B7:  GOTO   496
.................... } 
....................  
.................... void setaRPM(int16 rpm){         
....................    if(rpm>ultimaRPM){    
*
040C:  MOVF   31,W
040D:  SUBWF  40,W
040E:  BTFSS  03.0
040F:  GOTO   443
0410:  BTFSS  03.2
0411:  GOTO   416
0412:  MOVF   3F,W
0413:  SUBWF  30,W
0414:  BTFSC  03.0
0415:  GOTO   443
....................       avanca(rpm*passos_por_posicao); 
0416:  MOVF   40,W
0417:  MOVWF  44
0418:  MOVF   3F,W
0419:  MOVWF  43
041A:  CALL   027
041B:  MOVF   7A,W
041C:  MOVWF  44
041D:  MOVF   79,W
041E:  MOVWF  43
041F:  MOVF   78,W
0420:  MOVWF  42
0421:  MOVF   77,W
0422:  MOVWF  41
0423:  MOVF   37,W
0424:  MOVWF  48
0425:  MOVF   36,W
0426:  MOVWF  47
0427:  MOVF   35,W
0428:  MOVWF  46
0429:  MOVF   34,W
042A:  MOVWF  45
042B:  CALL   2AC
042C:  MOVF   7A,W
042D:  MOVWF  44
042E:  MOVF   79,W
042F:  MOVWF  43
0430:  MOVF   78,W
0431:  MOVWF  42
0432:  MOVF   77,W
0433:  MOVWF  41
0434:  CALL   321
0435:  MOVF   79,W
0436:  MOVWF  42
0437:  MOVF   78,W
0438:  MOVWF  41
0439:  MOVF   79,W
043A:  MOVWF  44
043B:  MOVF   78,W
043C:  MOVWF  43
043D:  CALL   23E
....................       ultimaRPM=rpm; 
043E:  MOVF   40,W
043F:  MOVWF  31
0440:  MOVF   3F,W
0441:  MOVWF  30
....................    }else if(rpm<ultimaRPM){ 
0442:  GOTO   4BC
0443:  MOVF   40,W
0444:  SUBWF  31,W
0445:  BTFSS  03.0
0446:  GOTO   4BC
0447:  BTFSS  03.2
0448:  GOTO   44D
0449:  MOVF   30,W
044A:  SUBWF  3F,W
044B:  BTFSC  03.0
044C:  GOTO   4BC
....................       retrocede(rpm*passos_por_posicao); 
044D:  MOVF   40,W
044E:  MOVWF  44
044F:  MOVF   3F,W
0450:  MOVWF  43
0451:  CALL   027
0452:  MOVF   7A,W
0453:  MOVWF  44
0454:  MOVF   79,W
0455:  MOVWF  43
0456:  MOVF   78,W
0457:  MOVWF  42
0458:  MOVF   77,W
0459:  MOVWF  41
045A:  MOVF   37,W
045B:  MOVWF  48
045C:  MOVF   36,W
045D:  MOVWF  47
045E:  MOVF   35,W
045F:  MOVWF  46
0460:  MOVF   34,W
0461:  MOVWF  45
0462:  CALL   2AC
0463:  MOVF   7A,W
0464:  MOVWF  44
0465:  MOVF   79,W
0466:  MOVWF  43
0467:  MOVF   78,W
0468:  MOVWF  42
0469:  MOVF   77,W
046A:  MOVWF  41
046B:  CALL   321
046C:  MOVF   79,W
046D:  MOVWF  42
046E:  MOVF   78,W
046F:  MOVWF  41
0470:  MOVF   42,W
0471:  MOVWF  44
0472:  MOVF   41,W
0473:  MOVWF  43
....................       ultimaRPM=rpm; 
*
04B8:  MOVF   40,W
04B9:  MOVWF  31
04BA:  MOVF   3F,W
04BB:  MOVWF  30
....................    } 
....................    printf(lcd_putc,"\f%lu RPM",ultimaRPM*100);  
04BC:  MOVF   31,W
04BD:  MOVWF  42
04BE:  MOVF   30,W
04BF:  MOVWF  41
04C0:  CLRF   44
04C1:  MOVLW  64
04C2:  MOVWF  43
04C3:  CALL   340
04C4:  MOVF   79,W
04C5:  MOVWF  42
04C6:  MOVF   78,W
04C7:  MOVWF  41
04C8:  MOVLW  0C
04C9:  MOVWF  4C
04CA:  CALL   1BE
04CB:  MOVLW  10
04CC:  MOVWF  04
04CD:  MOVF   42,W
04CE:  MOVWF  44
04CF:  MOVF   41,W
04D0:  MOVWF  43
04D1:  CALL   355
04D2:  MOVLW  0E
04D3:  BSF    03.6
04D4:  MOVWF  0D
04D5:  MOVLW  00
04D6:  MOVWF  0F
04D7:  BCF    03.0
04D8:  MOVLW  04
04D9:  BCF    03.6
04DA:  MOVWF  43
04DB:  CALL   3B8
....................     
.................... } 
04DC:  BCF    0A.3
04DD:  BCF    0A.4
04DE:  GOTO   57B (RETURN)
....................  
.................... void main () 
.................... {  
04DF:  CLRF   04
04E0:  BCF    03.7
04E1:  MOVLW  1F
04E2:  ANDWF  03,F
04E3:  MOVLW  FF
04E4:  MOVWF  20
04E5:  MOVLW  03
04E6:  MOVWF  21
04E7:  CLRF   22
04E8:  CLRF   2D
04E9:  CLRF   2C
04EA:  CLRF   2F
04EB:  CLRF   2E
04EC:  CLRF   31
04ED:  CLRF   30
04EE:  CLRF   33
04EF:  CLRF   32
04F0:  BSF    03.5
04F1:  BSF    1F.0
04F2:  BSF    1F.1
04F3:  BSF    1F.2
04F4:  BCF    1F.3
04F5:  MOVLW  07
04F6:  MOVWF  1C
....................    posicoes_na_escala = 60; //Simulando um contagiros até 6000 RPM 
*
0500:  CLRF   2B
0501:  MOVLW  3C
0502:  MOVWF  2A
....................    total_passos = 167; //Total de posições do motor entre o marcador 0 até 6 (passo a 1,8º) 
0503:  CLRF   29
0504:  MOVLW  A7
0505:  MOVWF  28
....................    passos_por_posicao = (float)total_passos/posicoes_na_escala; //Total de passos para cada posição no conta giros (a agulha anda de 50 em 50 RPM) 
0506:  MOVF   29,W
0507:  MOVWF  44
0508:  MOVF   28,W
0509:  MOVWF  43
050A:  CALL   027
050B:  MOVF   77,W
050C:  MOVWF  3F
050D:  MOVF   78,W
050E:  MOVWF  40
050F:  MOVF   79,W
0510:  MOVWF  41
0511:  MOVF   7A,W
0512:  MOVWF  42
0513:  MOVF   2B,W
0514:  MOVWF  44
0515:  MOVF   2A,W
0516:  MOVWF  43
0517:  CALL   027
0518:  MOVF   42,W
0519:  MOVWF  46
051A:  MOVF   41,W
051B:  MOVWF  45
051C:  MOVF   40,W
051D:  MOVWF  44
051E:  MOVF   3F,W
051F:  MOVWF  43
0520:  MOVF   7A,W
0521:  MOVWF  4A
0522:  MOVF   79,W
0523:  MOVWF  49
0524:  MOVF   78,W
0525:  MOVWF  48
0526:  MOVF   77,W
0527:  MOVWF  47
0528:  GOTO   044
0529:  MOVF   7A,W
052A:  MOVWF  37
052B:  MOVF   79,W
052C:  MOVWF  36
052D:  MOVF   78,W
052E:  MOVWF  35
052F:  MOVF   77,W
0530:  MOVWF  34
....................    lcd_init(); 
0531:  GOTO   18B
....................    delay_ms (100); 
0532:  MOVLW  64
0533:  MOVWF  4D
0534:  CALL   110
....................    
....................    SETUP_ADC_PORTS(AN0); 
0535:  BSF    03.5
0536:  BCF    1F.0
0537:  BSF    1F.1
0538:  BSF    1F.2
0539:  BSF    1F.3
....................    SETUP_ADC(ADC_CLOCK_DIV_16); 
053A:  BSF    1F.6
053B:  BCF    03.5
053C:  BSF    1F.6
053D:  BCF    1F.7
053E:  BSF    03.5
053F:  BSF    1F.7
0540:  BCF    03.5
0541:  BSF    1F.0
....................    
....................    set_adc_channel(0); 
0542:  MOVLW  00
0543:  MOVWF  78
0544:  MOVF   1F,W
0545:  ANDLW  C7
0546:  IORWF  78,W
0547:  MOVWF  1F
....................    delay_us (20); 
0548:  MOVLW  06
0549:  MOVWF  77
054A:  DECFSZ 77,F
054B:  GOTO   54A
054C:  NOP
....................     
....................    printf(lcd_putc,"\fPosicionando...");    
054D:  MOVLW  11
054E:  BSF    03.6
054F:  MOVWF  0D
0550:  MOVLW  00
0551:  MOVWF  0F
0552:  BCF    03.6
0553:  CALL   1F3
....................    avanca(117); // 0 RPM    
0554:  CLRF   44
0555:  MOVLW  75
0556:  MOVWF  43
0557:  CALL   23E
....................    passos_dados=0;    
0558:  CLRF   2F
0559:  CLRF   2E
....................    printf(lcd_putc,"\f0 RPM"); 
055A:  MOVLW  1A
055B:  BSF    03.6
055C:  MOVWF  0D
055D:  MOVLW  00
055E:  MOVWF  0F
055F:  BCF    03.6
0560:  CALL   1F3
....................     
....................          
....................  /*  for (i_1=0;i_1<5;i_1++){      
....................       delay_us (300); 
....................       setaRPM(rpms[i_1]); 
....................    }*/ 
....................  
....................    
....................   while(true){ 
....................  
....................       ad_atual = read_adc(); 
0561:  BSF    1F.2
0562:  BTFSC  1F.2
0563:  GOTO   562
0564:  BSF    03.5
0565:  MOVF   1E,W
0566:  BCF    03.5
0567:  MOVWF  26
0568:  MOVF   1E,W
0569:  MOVWF  27
....................        
....................       rpm = ad_atual/15; 
056A:  MOVF   27,W
056B:  MOVWF  40
056C:  MOVF   26,W
056D:  MOVWF  3F
056E:  CLRF   42
056F:  MOVLW  0F
0570:  MOVWF  41
0571:  GOTO   285
0572:  MOVF   79,W
0573:  MOVWF  33
0574:  MOVF   78,W
0575:  MOVWF  32
....................        
....................       setaRPM(rpm); 
0576:  MOVF   33,W
0577:  MOVWF  40
0578:  MOVF   32,W
0579:  MOVWF  3F
057A:  GOTO   40C
....................       
....................       printf(lcd_putc,"\f%lu RPM  ad: %lu",rpm*100, ad_atual ); 
057B:  MOVF   33,W
057C:  MOVWF  42
057D:  MOVF   32,W
057E:  MOVWF  41
057F:  CLRF   44
0580:  MOVLW  64
0581:  MOVWF  43
0582:  CALL   340
0583:  MOVF   79,W
0584:  MOVWF  40
0585:  MOVF   78,W
0586:  MOVWF  3F
0587:  MOVLW  0C
0588:  MOVWF  4C
0589:  CALL   1BE
058A:  MOVLW  10
058B:  MOVWF  04
058C:  MOVF   40,W
058D:  MOVWF  44
058E:  MOVF   3F,W
058F:  MOVWF  43
0590:  CALL   355
0591:  MOVLW  20
0592:  BSF    03.6
0593:  MOVWF  0D
0594:  MOVLW  00
0595:  MOVWF  0F
0596:  BCF    03.0
0597:  MOVLW  0A
0598:  BCF    03.6
0599:  MOVWF  43
059A:  CALL   3B8
059B:  MOVLW  10
059C:  MOVWF  04
059D:  MOVF   27,W
059E:  MOVWF  44
059F:  MOVF   26,W
05A0:  MOVWF  43
05A1:  CALL   355
....................       
....................       
....................      delay_ms (20); 
05A2:  MOVLW  14
05A3:  MOVWF  4D
05A4:  CALL   110
....................       
....................   } 
05A5:  GOTO   561
....................    
.................... } 
....................  
....................   /* 
....................   while(true){ 
....................  
....................      ad_atual = read_adc(); 
....................  
....................      distancia = ad_atual - ad_antigo;    
....................      printf(lcd_putc,"\fnow:%lu d:%ld\nold:%lu pp:%f",ad_atual,distancia, ad_antigo,passos_por_posicao ); 
....................       
....................      if (distancia != 0) 
....................      { 
....................         if (distancia > 0) 
....................         { 
....................            y = 0.195 * distancia;             
....................            for (j=0;j<y;j++) 
....................            {  
....................               output_b(motor[i_1]); 
....................               i_1++; 
....................               if (i_1 > 3) 
....................               { 
....................                  i_1 = 0; 
....................               } 
....................               delay_ms(frame_time); 
....................            } 
....................         }             
....................         else if (distancia < 0) 
....................         { 
....................            y = 0.195 * distancia * -1;             
....................            for (j=0;j<y;j++) 
....................            {                                 
....................               output_b(motor[i]); 
....................               i--; 
....................               if (i == 255) 
....................               { 
....................                  i = 3; 
....................               } 
....................               delay_ms(frame_time); 
....................            } 
....................         } 
....................      } 
....................       
....................      ad_antigo = ad_atual; 
....................      delay_ms (20); 
....................       
....................   } 
....................   */ 
....................  
05A6:  SLEEP

Configuration Fuses:
   Word  1: 3F71   XT NOWDT PUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
